/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 22.04.0 ] */
/* [wxMaxima: input   start ] */
/* Date: Mon Jun 4 07:39:28 WEST 2001 */
/* Contributor: William Schelter */
/* Description: Implementation of extended euclidean algorithm */
gcdex(f,g):=block(
    [q0,q1,ok:true,lis1,lis2,lis3,q,tem,var:listofvars([f,g]),swap:false],
    if (length(var) > 1) then merror("only univariate polynomials"),
    var:var[1],
    q0:divide(f,g),   /* divide(f,g) ==> [q:quotient(f,g),remainder:f-g*q] */
	      /* if f/g is 0 then we reverse them */
    if (q0[1]=0) then (
        lis2:gcdex(g,f),
        return([lis2[2],lis2[1],lis2[3]])
    ),
    if (q0[2]=0) then return([0,1,g]),
    q1:divide(g,q0[2]),
    lis1:[1,-q0[1],q0[2]],
    if (q1[2]=0) then (
        if numberp(lis1[3]) then lis1:lis1/lis1[3],
        return(lis1)),
      /* lisi are always perpendicular to [f,g,-1] */
    lis2:[-q1[1],1+q0[1]*q1[1], q1[2]],
    while (ok) do (
        q:divide(lis1[3],lis2[3]),
        lis3:ratsimp(lis1-lis2*q[1]),
        tem:content(lis3[3],var)[1],
        if (not(tem=0)) then lis3:ratsimp(lis3/tem),
        if(lis3[3] = 0) then ok:false else (lis1:lis2, lis2:lis3)
    ),
    if numberp(lis2[3]) then lis2/lis2[3] else lis2
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 4 18:20:46 WEST 2001 */
/* Contributor: Richard Fateman */
/* Description: Implementation of extended euclidean algorithm */
gcdex1(m,n,x):=
/* Given 2 expressions m and n in x, we compute their
GCD and two multipliers a and b such that a*m+b*n=d.
Knuth vol 1 algorithm E */
block(
    [ap,b,bp,r:1,q],
    [ap,b,a,bp,m,n]:[1,1,0,0,rat(m,x),rat(n,x)],
    loop,
    [q,r]:divide(m,n,x),
    if(r=0) then   [a,b,n]/content(n,x)[1] else (
        [m,n,t]:[n,r,ap],
        [ap,a,t,bp]: [a,t-q*a,bp,b],
        b:t-q*b,
        go (loop)
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Thu Oct 17 21:51:40 WEST 2013 */
/* Contributor: Adam Majewski */
/* Description: Routine for repeating decimals (as it is this gives some warnings) */

/* functions */

/* give decimal digit D of the long division step */
GiveD(leftover,divisor) := ceiling(float((10*leftover - divisor)/divisor))$

/* Give leftover for next step of long division */
GiveL(leftover,DecimalDigit,divisor) := 10*leftover - DecimalDigit*divisor$

/* ratio in lowest terms
   not working now
*/
GiveRatioType(ratio):=
(
   [numerator:num(ratio), FactorsList],
   FactorsList:ifactors(numerator),
   for f in FactorsList do if (first(first(f))!=2 and first(first(f))!=5)
      then return("repeating decimal expansion")
      else return("finite decimal expansion")
)$

compile(all)$

/* input numbers*/
a:19 $
b:27 $

/* automatic change to lowest terms */
dRatio:a/b;
/* GiveRatioType(dRatio); */
a: num(dRatio);
b: denom(dRatio);

dFloat:0.0 $  /* quotient */
k:0$ /* current position of decimal digit */
LeftoverList:[]$ /* list of leftovers */

/* Long Division of positive integers to Decimal Places ( without 
remainder ) */

/* first step */
L:a$
D:GiveD(L, b)$
k:k-1$
dFloat:dFloat +D*10^k$ /* save new digit to output float */
LeftoverList:cons(L,LeftoverList)$
disp(L,D)$

/* nest steps */

L:GiveL(L, D, b)$
while (not member(L,LeftoverList))  /* test for the end of repeating 
sequence */
do
  (
   D:GiveD(L, b),
   k:k-1,
   dFloat:dFloat +D*10^k, /* save new digit to output float */
   LeftoverList:cons(L,LeftoverList),
   disp(L,D),
   L:GiveL(L, D, b)
  )$

disp(dFloat)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Apr 5 18:13:36 WEST 2010 */
/* Contributor: Luigi Marino */
/* Description: returns the n-th prime number */
primo(n):=block(
    if n=1 then return(2) else (
        p:1,
        k:1
    ),
    while k#n do (
        p:p+2,
        d:2,
        while (d*d<=p and mod(p ,d)#0) do (
            d:d+1
        ),
        if d*d>p then k:k+1
    ),
    return(p)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sun Apr 11 18:39:07 WEST 2010 */
/* Contributor: Jaime Villate */
/* Description: returns the n-th prime number */
primo2(n) := block(
    [i : n, p : 2],
    while i > 1 do (
        i : i - 1,
        p : next_prime(p)
    ),
    return(p)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 14 22:06:34 WEST 2010 */
/* Contributor: Eric Reyssat */
/* Description: Farey sequence */
fc2(n):=block(
    L:[[0,1]],a:0,b:1,c:1,d:n,
    while 2*c<d do (
        k:floor ((b+n)/d),
        e:k*c-a,
        f:k*d-b,
        a:c,
        b:d,
        c:e,
        d:f, 
        L:cons([a,b],L)
    ),
    append(reverse(L) , [[1,2]] , map(lambda([x],[x[2]-x[1],x[2]]),L))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 14 22:22:14 WEST 2010 */
/* Contributor: Starvros Macrakis */
/* Description: Farey sequence */
fc3(n):=block(L:[0],a:0,b:1,c:1,d:n,
    while 2*c < d do (
        k:floor((b+n)/d),
        e:k*c-a,
        f:k*d-b,
        a:c,
        b:d,
        c:e,
        d:f,
        L:cons(a/b,L)
    ),
    append(reverse(L),[1/2],1-L)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue Jun 15 03:22:16 WEST 2010 */
/* Contributor: Barton Willis */
/* Description: Farey sequence */
h(n) := block(
    [d,j,l : [[0],[1]]],
    d : setify(makelist(i,i,floor(n/2),n)),
    while not emptyp(d) do (
        j : last(d),
        d : setdifference(d, divisors(j)),
        l : cons(makelist(i/j,i,1,j-1),l)
    ),
    setify(xreduce('append,l))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue Jun 15 18:02:41 WEST 2010 */
/* Contributor: Adam Majewski */
/* Description: Farey sequence */
F(n):=block(
    [a],
    a:[0/1,1/1],
    if n>=2 then 
    for denominator:2 thru n step 1 do 
    for numerator:1 thru (denominator-1) step 1 do 
    a:cons(numerator/denominator,a),
    return(setify(a))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sun Jun 13 22:02:36 WEST 2010 */
/* Contributor: Barton Willis */
/* Description: Farey sequence */
ff(n) := setify(xreduce('append, makelist(makelist(i/j,i,0,j), j,1, n)))$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 14 07:46:18 WEST 2010 */
/* Contributor: Eric Reyssat */
/* Description: Farey sequence */
ff2(n) := setify(xreduce('append, makelist(makelist(i/j,i,0,j), j,floor(n/2), n)))$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue, 13 Jun 2006 19:38:53 +0200 */
/* Contributor: Andrej Vodopivec */
/* Description: Implementation of Fermat factorization */
factor_fermat(n) := block(
    [a, b],
    a : isqrt(n),
    b : a*a-n,
    while isqrt(b)#sqrt(b) do (
        a : a+1,
        b : a*a-n
    ),
    return(a-isqrt(b))
    )$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sun Oct 17 23:29:22 WEST 2004 */
/* Contributor: Stavros Macrakis */
/* Description: A code for modular exponentiation */
modexpt(a,b,modulus):=block(
    [result],
    result: ratdisrep( rat(a)^b ),
    if result>=0 then result else result+modulus)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Nov 21 16:32:15 WET 2011 */
/* Contributor: Stavros Macrakis */
/* Description: A code for polynomial reduction in finite fields */
/* Note: Computations of this kind can be achieved using let, letsimp and obviously rat and modulus */
iratsubst(a,b,c,modulus):=(
    a:rat(a),b:rat(b),c:rat(c),
    while (c # (c:ratsubst(a,b,c))) do 1,
    c
)$
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 22.04.0"$
