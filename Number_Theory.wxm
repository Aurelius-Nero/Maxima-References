/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 22.04.0 ] */
/* [wxMaxima: input   start ] */
/* Date: Thu Oct 17 21:51:40 WEST 2013 */
/* Contributor: Adam Majewski */
/* Description: Routine for repeating decimals (as it is this gives some warnings) */

/* functions */

/* give decimal digit D of the long division step */
GiveD(leftover,divisor) := ceiling(float((10*leftover - divisor)/divisor))$

/* Give leftover for next step of long division */
GiveL(leftover,DecimalDigit,divisor) := 10*leftover - DecimalDigit*divisor$

/* ratio in lowest terms
   not working now
*/
GiveRatioType(ratio):=
(
   [numerator:num(ratio), FactorsList],
   FactorsList:ifactors(numerator),
   for f in FactorsList do if (first(first(f))!=2 and first(first(f))!=5)
      then return("repeating decimal expansion")
      else return("finite decimal expansion")
)$

compile(all)$

/* input numbers*/
a:19 $
b:27 $

/* automatic change to lowest terms */
dRatio:a/b;
/* GiveRatioType(dRatio); */
a: num(dRatio);
b: denom(dRatio);

dFloat:0.0 $  /* quotient */
k:0$ /* current position of decimal digit */
LeftoverList:[]$ /* list of leftovers */

/* Long Division of positive integers to Decimal Places ( without 
remainder ) */

/* first step */
L:a$
D:GiveD(L, b)$
k:k-1$
dFloat:dFloat +D*10^k$ /* save new digit to output float */
LeftoverList:cons(L,LeftoverList)$
disp(L,D)$

/* nest steps */

L:GiveL(L, D, b)$
while (not member(L,LeftoverList))  /* test for the end of repeating 
sequence */
do
  (
   D:GiveD(L, b),
   k:k-1,
   dFloat:dFloat +D*10^k, /* save new digit to output float */
   LeftoverList:cons(L,LeftoverList),
   disp(L,D),
   L:GiveL(L, D, b)
  )$

disp(dFloat)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 14 22:06:34 WEST 2010 */
/* Contributor: Eric Reyssat */
/* Description: Farey sequence */
fc2(n):=block(
    L:[[0,1]],a:0,b:1,c:1,d:n,
    while 2*c<d do (
        k:floor ((b+n)/d),
        e:k*c-a,
        f:k*d-b,
        a:c,
        b:d,
        c:e,
        d:f, 
        L:cons([a,b],L)
    ),
    append(reverse(L) , [[1,2]] , map(lambda([x],[x[2]-x[1],x[2]]),L))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 14 22:22:14 WEST 2010 */
/* Contributor: Starvros Macrakis */
/* Description: Farey sequence */
fc3(n):=block(L:[0],a:0,b:1,c:1,d:n,
    while 2*c < d do (
        k:floor((b+n)/d),
        e:k*c-a,
        f:k*d-b,
        a:c,
        b:d,
        c:e,
        d:f,
        L:cons(a/b,L)
    ),
    append(reverse(L),[1/2],1-L)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue Jun 15 03:22:16 WEST 2010 */
/* Contributor: Barton Willis */
/* Description: Farey sequence */
h(n) := block(
    [d,j,l : [[0],[1]]],
    d : setify(makelist(i,i,floor(n/2),n)),
    while not emptyp(d) do (
        j : last(d),
        d : setdifference(d, divisors(j)),
        l : cons(makelist(i/j,i,1,j-1),l)
    ),
    setify(xreduce('append,l))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue Jun 15 18:02:41 WEST 2010 */
/* Contributor: Adam Majewski */
/* Description: Farey sequence */
F(n):=block(
    [a],
    a:[0/1,1/1],
    if n>=2 then 
    for denominator:2 thru n step 1 do 
    for numerator:1 thru (denominator-1) step 1 do 
    a:cons(numerator/denominator,a),
    return(setify(a))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sun Jun 13 22:02:36 WEST 2010 */
/* Contributor: Barton Willis */
/* Description: Farey sequence */
ff(n) := setify(xreduce('append, makelist(makelist(i/j,i,0,j), j,1, n)))$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Jun 14 07:46:18 WEST 2010 */
/* Contributor: Eric Reyssat */
/* Description: Farey sequence */
ff2(n) := setify(xreduce('append, makelist(makelist(i/j,i,0,j), j,floor(n/2), n)))$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue, 13 Jun 2006 19:38:53 +0200 */
/* Contributor: Andrej Vodopivec */
/* Description: Implementation of Fermat factorization */
factor_fermat(n) := block(
    [a, b],
    a : isqrt(n),
    b : a*a-n,
    while isqrt(b)#sqrt(b) do (
        a : a+1,
        b : a*a-n
    ),
    return(a-isqrt(b))
    )$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sun Oct 17 23:29:22 WEST 2004 */
/* Contributor: Stavros Macrakis */
/* Description: A code for modular exponentiation */
modexpt(a,b,modulus):=block(
    [result],
    result: ratdisrep( rat(a)^b ),
    if result>=0 then result else result+modulus)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Mon Nov 21 16:32:15 WET 2011 */
/* Contributor: Stavros Macrakis */
/* Description: A code for polynomial reduction in finite fields */
/* Note: Computations of this kind can be achieved using let, letsimp and obviously rat and modulus */
iratsubst(a,b,c,modulus):=(
    a:rat(a),b:rat(b),c:rat(c),
    while (c # (c:ratsubst(a,b,c))) do 1,
    c
)$
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 22.04.0"$
